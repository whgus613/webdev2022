## 기초웹개발론 과제
### 강의 요약 정리 & 코딩테스트 풀이  

<br/>

### 2022.09.05

<br/>

[최솟값 만들기(프로그래머스 Level 2)](https://school.programmers.co.kr/learn/courses/30/lessons/12941)    
  
```
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int solution(vector<int> A, vector<int> B)
{
    int answer = 0;

    sort(A.begin(), A.end());
    sort(B.begin(), B.end(), greater<>());
    
    for(int i = 0; i < A.size(); i++){
        answer += A[i] * B[i];
    }

    return answer;
}
```

벡터 A는 오름차순으로, 벡터 B는 내림차순으로 정렬한 후 각 요소를 곱해주면 된다.

<br/>

---

<br/>


### 2022.09.06


<br/>

**프로그래밍언어론**

<br/>

추상화는 readablitiy 증가를 목적으로 함

- 추상화의 범주
    - 자료 추상화
        - 컴퓨터 내부의 자료 표현을 추상화 <- 변수(기억장치), 자료형(2진수의 내부 표현값)
        - 관련된 자료의 집합을 추상화 <- 배열, 레코드
        - 자료의 생성과 사용에 대한 정보를 모아두고 자료의 세부사항에 대한 접근 제한 <- C++, Java의 class
    - 제어 추상화
        - 몇 개의 기계 명령어를 이해하기 쉬운 추상 구문으로 만드는 것 <- GOTO 문
        - 프로그램에서 어떤 검사된 값에 따라 분할된 명령어의 한 그룹을 수행 <- If, case, switch
        - 프로시저의 집합을 추상화 <- package, library 함수
        

<br>

**임베디드컴퓨팅**

<br/>

- 임베디드
    - 가상공간과 물리공간의 상호작용과 연결을 위해 사물에 마이크로 컴퓨터를 내장하는 것
- 스마트 사회
    - 모든 컴퓨터가 서로 연결되고 이용자 눈에 보이지 않으며, 어디서나 이용 가능하고 현실세계의 사물과 환경 속으로 스며들어 일상생활에 통합되는 스마트 서비스를 제공하는 사회


<br/>

---

<br/>

### 2022.09.07

<br/>

[피보나치 수(프로그래머스 Level 2)](https://school.programmers.co.kr/learn/courses/30/lessons/12945)    
  
```
#include <string>
#include <vector>

using namespace std;

int solution(int n) {
    int answer = 0;
    
    int f[100001];
    
    f[0] = 0; f[1] = 1;
    
    for(int i = 2; i <= n; i++){
        f[i] = (f[i - 1] + f[i - 2]) % 1234567;
    }
    
    answer = f[n];
    
    return answer;
}
```

피보나치 수를 재귀함수를 사용해 구할 경우 시간초과가 나므로, 배열과 반복을 활용해 이전 값을 활용하도록 했다.

<br/>

---

<br/>

### 2022.09.08

<br/>

[짝지어 제거하기(프로그래머스 Level 2)](https://school.programmers.co.kr/learn/courses/30/lessons/12973)    
  
```
#include <iostream>
#include <string>
#include <stack>
using namespace std;

int solution(string s)
{
    int answer = -1;
    stack<char> st;
    
    for(int i = 0; i < s.size(); i++){
        if((st.size() > 0) && (st.top() == s[i]))
            st.pop();
        else
            st.push(s[i]);
    }

    answer = !(st.size());

    return answer;
}
```

스택을 사용해 알파벳을 비교하고 같다면 pop을, 아니라면 push를 한다.

<br/>

---

<br/>

### 2022.09.13

<br/>

[완주하지 못한 선수(프로그래머스 Level 1)](https://school.programmers.co.kr/learn/courses/30/lessons/42576)    
  
```
#include <string>
#include <vector>
#include <unordered_map>

using namespace std;

string solution(vector<string> participant, vector<string> completion) {
    string answer = "";
    
    unordered_map<string, int> m;
    
    for (string name : participant){
        m[name]++;
    }
    
    for (string name : completion){
        m[name]--;
    }
    
    for (auto pair : m){
        if (pair.second > 0){
            answer = pair.first;
            break;
        }
    }
    
    return answer;
}
```

참가자 명단과 완주자 명단의 해시맵을 만들고, 그 둘을 비교해 같은 이름이 있으면 참가자 해시맵에서 해당 쌍의 밸류 값을 감소시킨다.
모든 해시맵의 반복이 끝난 후 참가자 해시맵에서 밸류 값이 1 이상인 쌍이 있다면 그 쌍의 키 값이 완주하지 못한 선수의 이름이다.

<br/>

---

<br/>

### 2022.09.14

<br/>

[신규 아이디 추천(프로그래머스 Level 1)](https://school.programmers.co.kr/learn/courses/30/lessons/72410)    
  
```

#include <string>
#include <vector>
#include <algorithm>

using namespace std;

string solution(string new_id) {
    string answer = "";
    
    for (int i = 0; i < new_id.size(); i++){
        if(new_id[i] >= 'A' && new_id[i] <= 'Z')
            new_id[i] = tolower(new_id[i]);
    }
    
    for (int i = 0; i < new_id.size();){
        if ((new_id[i] >= 'a' && new_id[i] <= 'z') || (new_id[i] >= '0' && new_id[i] <= '9') || new_id[i] == '-' || new_id[i] == '.' || new_id[i] == '_'){
            i++;
            continue;
        }
        new_id.erase(new_id.begin() + i);
    }
    
    for(int i = 1; i < new_id.length(); ){
        if (new_id[i] == '.' && new_id[i - 1] == '.'){
            new_id.erase(new_id.begin() + i);
            continue;
        }
        else i++;
    }
    
    if (new_id.front() == '.') new_id.erase(new_id.begin());
    if (new_id.back() == '.') new_id.erase(new_id.end() - 1);
    
    if (new_id == "") new_id = "a";
    
    if (new_id.size() >= 16){
        while(new_id.size() != 15)
            new_id.erase(new_id.end() - 1);
    }
     if (new_id.back() == '.') new_id.erase(new_id.end() - 1);
    
    if (new_id.size() <= 2){
        while(new_id.size() != 3){
            new_id += new_id.back();
        }
    }
    
    return new_id;
}

```

<br/>

---

<br/>


### 2022.09.19


<br/>

**프로그래밍언어론**

<br/>

언어의 변천

- 1950년대
    - 최초의 프로그래밍 언어
        - 기계어 사용
        - FORTRAN 
        - COBOL, ALGOL 60, LISP, APL
- 1960년대
    - 프로그래밍 언어의 폭증
        - PL/I
        - algol68
        - Snobol, Simula67, Basic
- 1970년대
    - 간결성, 추상화, 연구사항
        - Pascal, C
        - CLU, Euclid, Mesa
- 1980년대
    - 통합과 새로운 방향
        - Ada, Modula-2
        - Prolog, SETL, C++
        - Scheme, Common Lisp
- 1990년대
    - World Wide Web 프로그래밍
        - Java, HTML
        
     
<br/>

---

<br/>


### 2022.09.20


<br/>

**임베디드 시스템**

<br/>

임베디드 시스템의 입출력 장치와 메모리

- 입력 장치
    - 프로그램이나 데이터를 컴퓨터가 인식할 수 있는 부호로 바꾸어 주기억 장치로 보내는 장치
    - 임베디드 시스템에서는 입력 장치로 센서가 주로 사용됨
- 출력 장치
    - 주기억 장치에서 데이터를 처리한 결과를 외부에 명령이나 데이터로 전달하는 장치
    - 임베디드 시스템의 출력 장치는 다양한 구동체에, 연결 임베디드 시스템의 출력 장치는 다양한 구동체에 연결
- 메모리
    - 데이터나 명령에 의해 컴퓨터 내부에서 계산 처리를 기억하는 장치
    - 휘발성 메모리(DRAM, SRAM), 비휘발성 메모리(ROM, 플래시 메모리) 

<br/>

---

<br/>

### 2022.09.21


<br/>

**프로그래밍 언어론**

<br/>

언어 설계의 기본 원칙

- 효율성(efficiency)
- 일반성(generality)
- 직교성(orthogonality)
- 획일성(uniformity)
- 기타 설계 원칙
    - 간결성
    - 안정성
    - 표현력
    - 기존 표기나 규칙과의 일관성
    - 정확성
    - 확장성
    - 기계 독립성
    - 제약성, 부분성

<br/>

---

<br/>

### 2022.09.22

<br/>

[이진 변환 반복(프로그래머스 Level 2)](https://school.programmers.co.kr/learn/courses/30/lessons/70129)    
  
```

#include <string>
#include <vector>
#include <algorithm>

using namespace std;

vector<int> solution(string s) {
    vector<int> answer(2);
    
    while(s != "1"){
        string tmp = "";
        
        for(int i = 0; i < s.size(); i++){
            if (s[i] == '0'){
                answer[1]++;
            }
            else
                tmp += "1";
        }
        
        int x = tmp.size();
        
        string r = "";
        
        while(x != 0){
            r += to_string(x % 2);
            x /= 2;
        }
        
        reverse(r.begin(), r.end());
        
        s = r;
        
        answer[0]++;
        
    }
    
    return answer;
}

```

<br/>

---

<br/>

### 2022.09.27


<br/>

[카펫(프로그래머스 Level 2)](https://school.programmers.co.kr/learn/courses/30/lessons/42842)

<br/>

```
#include <string>
#include <vector>

using namespace std;

vector<int> solution(int brown, int yellow) {
    vector<int> answer(2);
    
    int sum = brown + yellow;
    
    for (int height = 3; ; height++){
        if (!(sum % height)){
            int weight = sum / height;
            if (((height - 2) * (weight - 2)) == yellow){
                answer[0] = weight;
                answer[1] = height;
                break;
            }
        }
    }
    
    return answer;
}
```

<br/>

---

<br/>


### 2022.09.28


<br/>

**프로그래밍 언어론**

<br/>

 C.A.R Hoare의 성공적인 프로그래밍 언어 설계를 위한 충고

- 언어의 특정한 특성 고안
    - 새 특성의 설계자는 한 번에 한 가지 특성에만 집중
    - 잘 알려진 언어의 특성 구현
    - 이미 존재하는 언어의 장점을 해치지 않고, 단점과 불완전성을 해결하고 완화하는 것을 확신해야 함
    - 사용자 지침서 작성
    - 많은 예제 프로그램 작성
- 새로운 언어 설계
    - 기존의 많은 특성들: 숙지, 선택, 판단력 구비
    - 특성들 사이의 불일치 제거
    - 새 언어의 영역, 목적, 범위, 복잡성, 확장성에 대한 명확한 개념
    - 실제 구현과 사용자 지침서 제공

<br/>

---

<br/>


### 2022.09.29


<br/>

[H-Index(프로그래머스 Level 2)](https://school.programmers.co.kr/learn/courses/30/lessons/42747)

<br/>

```
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int solution(vector<int> citations) {
    int answer = 0;
    
    sort(citations.begin(), citations.end(), greater<int>());
    
    for (int i = 0; i < citations.size(); i++){
        if (citations[i] >= (i + 1))
            answer++;
    }
    
    
    return answer;
}
```

<br/>

---

<br/>


### 2022.09.30


<br/>

[멀쩡한 사각형(프로그래머스 Level 2)](https://school.programmers.co.kr/learn/courses/30/lessons/62048)

<br/>

```
using namespace std;

long long gcd(int a, int b){
    long c;
    while(b != 0){
        c = a % b;
        a = b;
        b = c;
    }
    return a;
}


long long solution(int w,int h) {
    long long W = w;
    long long H = h;
    long long tmp = (w + h) - gcd(w, h);
    
    return W * H - tmp;
}
```

<br/>

---

<br/>


### 2022.10.04


<br/>

[모의고사(프로그래머스 Level 1)](https://school.programmers.co.kr/learn/courses/30/lessons/42840)

<br/>

```
#include <string>
#include <vector>

using namespace std;

vector<int> solution(vector<int> answers) {
    vector<int> answer;
    int temp[] = {0, 0, 0};
    int supo1[] = {1, 2, 3, 4, 5};
    int supo2[] = {2, 1, 2, 3, 2, 4, 2, 5};
    int supo3[] = {3, 3, 1, 1, 2, 2, 4, 4, 5, 5};
    int max = 0;
    
    int s1 = sizeof(supo1) / sizeof(int);
    int s2 = sizeof(supo2) / sizeof(int);
    int s3 = sizeof(supo3) / sizeof(int);
    
    for (int i = 0; i < answers.size(); i++){
        if (answers[i] == supo1[i % s1]){
            temp[0]++;
        }
    }
    
    for (int i = 0; i < answers.size(); i++){
        if (answers[i] == supo2[i % s2]){
            temp[1]++;
        }
    }
    
    for (int i = 0; i < answers.size(); i++){
        if (answers[i] == supo3[i % s3]){
            temp[2]++;
        }
    }
    
    for (int i = 0; i < 3; i++){
        if (temp[i] > max){
            max = temp[i];
        }
    }
    
    for (int i = 0; i < 3; i++){
        if (temp[i] == max){
            answer.push_back(i + 1);
        }
    }
    
    return answer;
}
```

<br/>

---

<br/>


### 2022.10.05


<br/>

**프로그래밍언어론**

<br/>

어휘 구조 용어

- 어휘 토큰, 어휘 요소, 어휘 단위
    - 기본 의미 단위를 표현하는 한 개 이상의 프로그래밍 언어의 알파벳 문자로 구성된 문자열
- 언어 구성자
    - 한 개 이상의 어휘 토큰으로 형성되며, 구문적으로 허용된 프로그램의 일부
- 식별자, 미리 정의된 식별자, 예약어
    - 언어 어휘를 구성하는 단어나 기호 형태의 문자 알파벳, 변수 이름으로 사용할 수 없음
    - 장점: 프로그램 판독성 증가, 컴파일러가 기호 테이블을 빠른 시간에 탐색
    - 많은 예약어 -> 언어 확장시 새 예약어와 이전에 사용된 프로그램의 식별자와 중복 우려
- 구분자, 분리자
        
     
<br/>

---

<br/>


### 2022.10.06


<br/>

**데이터리터러시**

<br/>

문제해겨르이 범위 설정을 위해 CoNVO 기법을 사용

- Context
    - 문제가 생긴 이유 및 데이터가 문제와 어떤 관련이 있는지 파악
- Need
    - 문제가 왜 생겨났는지를 문제의 양상과 연결
- Vision
    - 데이터 분석이 추구하는 예상 결론
- Outcome
    - 데이터 분석을 통한 문제해결 시 기대할 수 있는 효과
        
     
<br/>

---

<br/>


### 2022.10.07


<br/>

[하노이의 탑(프로그래머스 Level 2)](https://school.programmers.co.kr/learn/courses/30/lessons/12946)

<br/>

```
#include <string>
#include <vector>

using namespace std;

void Hanoi(vector<vector<int>>& answer, int n, int start, int dest){
    if (n == 1){
        answer.push_back({start, dest});
        return;
    }
    
    Hanoi(answer, n - 1, start , 6 - start - dest);
    answer.push_back({start, dest});
    Hanoi(answer, n - 1, 6 - start - dest, dest);
    
}


vector<vector<int>> solution(int n) {
    vector<vector<int>> answer;
    
    Hanoi(answer, n, 1, 3);
    
    return answer;
}
```

<br/>

---

<br/>

### 2022.10.10


<br/>

[폰켓몬(프로그래머스 Level 1)](https://school.programmers.co.kr/learn/courses/30/lessons/1845)

<br/>

```
#include <vector>
#include <algorithm>

using namespace std;

int solution(vector<int> nums)
{
    int answer = 0, x = 0;
    
    x = nums.size() / 2;
    
    sort(nums.begin(), nums.end());
    
    nums.erase(unique(nums.begin(), nums.end()), nums.end());
    
    if (x > nums.size())
        answer = nums.size();
    else
        answer = x;
    
    return answer;
}
```

<br/>

---

<br/>


### 2022.10.12


<br/>

**프로그래밍 언어론**

<br/>

프로그래밍 언어의 구문과 구현 기법

- 파스 트리(Parse Tree)
    - 원시 프로그램의 문법 검사 과정에서 내부적으로 생성되는 트리 형태의 자료구조
    - 문장 표현이 BNF에 의해 작성될 수 있는지 여부를 나타냄
    - 예: 식별자에 대한 BNF를 통해 다음 TEST1에 대한 파스 트리 작성

<br/>

---

<br/>

### 2022.10.13


<br/>

[체육복(프로그래머스 Level 1)](https://school.programmers.co.kr/learn/courses/30/lessons/42862)

<br/>

```
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int solution(int n, vector<int> lost, vector<int> reserve) {
    
    for(int i = 0; i < lost.size(); i++){
        for (int j = 0; j < reserve.size(); j++){
            if (lost[i]  == reserve[j]){
                lost.erase(lost.begin() + i);
                reserve.erase(reserve.begin() + j);
                i = -1;
                break;
            }
        }
    }
    
    int answer = n - lost.size();
    
    sort(lost.begin(), lost.end());
    sort(reserve.begin(), reserve.end());
    
    for(int i = 0; i < lost.size(); i++){
        for (int j = 0; j < reserve.size(); j++){
            if (lost[i] - 1 == reserve[j] || lost[i] + 1 == reserve[j]){
                answer++;
                reserve.erase(reserve.begin() + j);
                break;
            }
        }
    }
    
    return answer;
}
```

<br/>

---

<br/>

### 2022.10.14


<br/>

[로또의 최고 순위와 최저 순위(프로그래머스 Level 1)](https://school.programmers.co.kr/learn/courses/30/lessons/77484)

<br/>

```
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

vector<int> solution(vector<int> lottos, vector<int> win_nums) {
    vector<int> answer;
    
    int same = 0, zero = 0;
	int rank[] = { 6, 6, 5, 4, 3, 2, 1 };

	zero = count(lottos.begin(), lottos.end(), 0);

	for (int i = 0; i < lottos.size(); i++) {
		for (int j = 0; j < win_nums.size(); j++) {
			if (lottos[i] == win_nums[j])
				same++;
		}
	}

	answer.push_back(rank[same + zero]);
	answer.push_back(rank[same]);
    
    return answer;
}
```

<br/>

---

<br/>


### 2022.10.17


<br/>

**컴퓨터일반**

<br/>

프로그래밍 언어의 발전

- 1세대 언어(1940년대)
    - 전자식 컴퓨터가 개발되자 기계어를 이용한 프로그래밍이 시작됨
    - 기계어 프로그래밍의 단점을 해결하기 위해 만든 어셈블리어를 만듦
    - 어셈블리어는 기계어보다 작성하기 쉽지만, 광범위한 적용에는 한계가 있었음
- 2세대 언어(1950~60년대)
    - 복잡한 프로그램을 작성하기에는 어셈블리어도 불편한 점이 있어 1950년대부터는 여러 고급 언어가 동시다발적으로 개발되기 시작함
    - 고급 언어를 기계어로 번역해주는 컴파일러도 개발됨
- 3세대 언어(1970년대)
    - 구조적 프로그래밍 기법을 따르는 파스칼과 C언어가 개발됨
    - 이러한 고급 언어를 바탕으로 유닉스와 MS-DOS 운영체제의 개발이 진행됨
- 4세대 언어(1980년대)
    - 하드웨어의 가격이 내려가자 개인용 컴퓨터가 대중화되기 시작했고, 더 크고 복잡한 프로그램을 개발하기 위해 객체지향프로그래밍 기법이 등장함
    - 다양한 ㅍ프로그래밍 개발 툴이 지원돼 C++, 오브젝트 C, 펄(Perl)등이 개발됨
- 5세대 언어(1990년대)
    - GUI 환경 프로그래밍을 위한 여러 클래스의 라이브러리가 등장하면서 객체 지향 언어의 장점이 크게 주목받음
    - 웹 프로그래밍이 보편화되면서 HTML, 자바스크립트 등의 언어가 개발됨
- 6세대 언어(2000년대)
    - 2000년대에 들어서자 더욱 간편하고 쉬운 방법으로 프로그래밍 작업을 하길 원하는 사람이 늘어 파워빌더, 델파이 등의 언어가 개발됨
    - 이외에도 C#, Go, 액션스크립트, 코틀린 등이 개발됨

<br/>

---

<br/>

### 2022.10.18


<br/>

[위장(프로그래머스 Level 2)](https://school.programmers.co.kr/learn/courses/30/lessons/42578)

<br/>

```
#include <string>
#include <vector>
#include <unordered_map>

using namespace std;

int solution(vector<vector<string>> clothes) {
    int answer = 1;
    
    unordered_map<string, int> m;
    
    for (auto cloth : clothes){
        m[cloth[1]]++;
    }
    
    for (auto pair : m){
        answer *= pair.second + 1;
    }
    
    return answer - 1;
}
```

<br/>

---

<br/>


### 2022.10.19


<br/>

[가장 큰 수(프로그래머스 Level 2)](https://school.programmers.co.kr/learn/courses/30/lessons/42746)

<br/>

```
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

bool sorting(string a, string b){
    return a + b > b + a;
}

string solution(vector<int> numbers) {
    string answer = "";
    vector<string> tmp;
    
    for (int i = 0; i < numbers.size(); i++){
        tmp.push_back(to_string(numbers[i]));
    }    
    
    sort(tmp.begin(), tmp.end(), sorting);
    
    for (int i = 0; i < tmp.size(); i++){
        answer += tmp[i];
    }
    
    if (answer[0] == '0'){
        return "0";
    }
    
    return answer;
}
```

<br/>

---

<br/>


### 2022.10.20


<br/>

[N개의 최소공배수(프로그래머스 Level 2)](https://school.programmers.co.kr/learn/courses/30/lessons/12953)

<br/>

```
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int GCD(int A, int B){
    int a = max(A, B);
    int b = min(A, B);
    
    while(a % b != 0){
        int r = a % b;
        a = b;
        b = r;
    }
    return b;
}


int solution(vector<int> arr) {
    int answer = arr[0];
    
    for(int i = 1; i < arr.size(); i++){
        int gcd = GCD(answer, arr[i]);
        int lcm = answer * arr[i] / gcd;
        answer = lcm;
    }
    
    
    return answer;
}
```

<br/>

---

<br/>

### 2022.10.24


<br/>

[올바른 괄호(프로그래머스 Level 2)](https://school.programmers.co.kr/learn/courses/30/lessons/12909)
<br/>

```
#include<string>
#include <iostream>
#include <stack>

using namespace std;

bool solution(string s)
{

    stack<char> stack;
    
    for (int i = 0; i < s.size(); i++){
        if (s[i] == '(')
            stack.push(s[0]);
        else {
            if(!stack.empty() && stack.top() == '(')
                stack.pop();
            else
                stack.push(')');
        }
    }
    
    if (stack.empty())
        return true;
    else
        return false;

}
```

<br/>

---

<br/>

### 2022.10.25


<br/>

[숫자의 표현(프로그래머스 Level 2)](https://school.programmers.co.kr/learn/courses/30/lessons/12924)
<br/>

```
#include <string>
#include <vector>

using namespace std;

int solution(int n) {
    int answer = 1, sum = 0;
    
    for (int i = 1; i < n; i++){
        sum = i;
        for (int j = i + 1; j < n; j++){
            sum += j;
            if (sum == n){
                answer++;
            }
            else if (sum > n){
                break;
            }
        }
    }
    
    return answer;
}
```

<br/>

---

<br/>

### 2022.10.25


<br/>

[짝지어 제거하기(프로그래머스 Level 2)](https://school.programmers.co.kr/learn/courses/30/lessons/12973)
<br/>

```
#include <iostream>
#include <string>
#include <stack>
using namespace std;

int solution(string s)
{
    int answer = -1;
    stack<char> st;
    
    for(int i = 0; i < s.size(); i++){
        if((st.size() > 0) && (st.top() == s[i]))
            st.pop();
        else
            st.push(s[i]);
    }

    answer = !(st.size());

    return answer;
}
```

<br/>

---

<br/>

### 2022.10.27


<br/>

[전화번호 목록(프로그래머스 Level 2)](https://school.programmers.co.kr/learn/courses/30/lessons/42577)
<br/>

```
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

bool solution(vector<string> phone_book) {
    
    sort(phone_book.begin(), phone_book.end());
    
    for (int i = 0; i < phone_book.size() - 1; i++){
        if (phone_book[i] == phone_book[i + 1].substr(0, phone_book[i].size()))
            return false;
    }
    
    
    return true;
}
```

<br/>

---

<br/>

### 2022.10.31


<br/>

[최고의 집합(프로그래머스 Level 3)](https://school.programmers.co.kr/learn/courses/30/lessons/12938)
<br/>

```
#include <string>
#include <vector>

using namespace std;

vector<int> solution(int n, int s) {
    vector<int> answer;
    
    int x;
    
    if (s < n)
        answer.push_back(-1);
    else{
        for(int i = 0; i < n; i++){
            answer.push_back(s / n);
        }
        for(int i = n - 1; i >= n - s % n; i--){
            answer[i]++;
        }
    }
    
    return answer;
}
```

<br/>

---

<br/>

